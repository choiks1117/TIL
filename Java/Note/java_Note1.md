 #  Java



> #### 프로그래밍 언어

\-   주어진 어떤 문제를 해결하기 위해 인간과 컴퓨터 사이에서 의사소통을 가능하게 하는 인공적인 언어

\-   사람과 컴퓨터 사이의 의사교환 수단

\-   명령 -> 결과 받아 (출력)

프로그래밍 언어 분류

1. 저급언어

\-   기계어

■   컴퓨터가 직접 이해할 수 있는 유일한 언어

■   0과 1로 표현

\-   어셈블리어

■   복잡한 기계어를 간략하게 기호화(심볼)함

2. 고급언어

\-   인간이 이해하기 쉽고 친근한 언어

\-   영어로 작성

\-   C / C++, Java 등

>  ### 자바(Java) 언어

\-   1995년 썬마이크로시스템즈(Sun Microsystems)에서 최초 발표한 언어

\-   1991년 가전 제품에서 사용할 목적인 오크(Oak) 언어에서부터 시작

\-   인터넷 프로그래밍 언어로 발전하면서 자바라는 이름으로 변경

\-   2010년 오라클에서 썬을 인수하여 Java 개발,관리,배포 주관

> ### 자바 언어의 특징

\-   플랫폼 독립적 (CPU나 운영체제에 상관없이 실행)

\-   이식성이 높은 언어

\-   WORA(Write Once Run Anywhere)

\-   진정한 의미의 객체 지향 언어(클래스, 상속, 다형성, 캡슐화 등)

\-   멀티쓰레드 지원(하나의 프로그램 내에서 여러 작업 동시 수행 개념)

\-   동적 로딩(Dynamic Loading) 지원

**■   미리 객체를 만들어 놓지 않고 필요한 시점에 동적 로딩해 객체 생성**

\-   유지 보수 시 특정 객체만 쉽게 수정 및 교체해 사용메모리 사용량이 적고 메모리 관리 문제 해결

**■   GC(Garbage Collector : 쓰레기 처리기)가 메모리 해제의 모든 것 처리**

**■   메모리를 자동으로 관리**

**◆  사용하지 않는 객체를 자동으로 메모리에서 제거**

**◆  핵심 기능 코드에 집중할 수 있도록 하는 기능**

\-   막강한 오픈 소스 라이브러리 풍부

#### 이식성이 높은 언어

![clip_image002](https://user-images.githubusercontent.com/101630615/173629195-6de2b19f-1107-4f2b-aafe-97d275f2e13d.jpg)

 

#### 자바 프로그램 실행 구조

![clip_image004](https://user-images.githubusercontent.com/101630615/173629204-d096f8e8-adb8-4af9-9954-99143f5e8be4.jpg)

#### 자바 가상 기계 (JVM : Java Virtual Machine)

\-   java.exe 명령어에 의해 구동

\-   바이트 코드를 기계어로 변환시키고 실행

\-   각 운영체제에 맞는 자바 가상 기계(JVM) 실행

**■   운영체제에 종속적**

 

#### 플랫폼 독립적

\-   CPU나 운영체제에 상관없이 실행



![clip_image006](https://user-images.githubusercontent.com/101630615/173629209-8fb3f5c7-ca48-4641-96a2-04759cebbefd.jpg)

 

##### WORA(Write Once Run Anywhere)

\-   한번 작성한 프로그램은 모든 플랫폼에서 실행 가능

 

![clip_image008](https://user-images.githubusercontent.com/101630615/173629215-3f0d565a-2f3e-4535-9bc9-7127bfab7d29.jpg)

### 자바 언어의 실행

\-   소스 코드(.java)를 입력하고 컴파일하면 

\-   바이트 코드 형태의 클래스 파일(.class) 생성

\-   (바이트 코드 : 특정 하드웨어가 아닌 가상 컴퓨터에서 실행되는 프로그램을 위한 이진 코드)

\-   자바 가상 기계(JVM)라는 가상의 CPU가 실행을 맡고 실제 CPU에게 처리를 맡김

\-   런타임(실행할 때) 필요한 클래스들이 자바 가상 기계에 의해 링크되고, 클래스 로더가 동적으로 필요한 클래스 로드



![clip_image010](https://user-images.githubusercontent.com/101630615/173629219-00da1b52-54f2-4085-80fd-c179a9c6d6d0.jpg)



#### 자바 응용프로그램 종류

\-   데스크톱 응용프로그램

\-   애플릿(Applet) 응용프로그램

\-   자바 서블릿(servlet) 응용프로그램

\-   모바일 응용프로그램

 

##### 데스크톱 응용프로그램

\-   PC 등의 데스크톱 컴퓨터에 설치되어 단독으로 실행

\-   자바 실행 환경(JRE)이 설치된 어떤 컴퓨터에서도 실행

\-   예: 이클립스, 게임 등

 

##### 애플릿(Applet) 응용프로그램

\-   웹 페이지에 내장되어 실행

\-   단독으로 실행될 수 없고 웹 브라우저에 의해 구동되고 실행 제어

\-   웹 서버에서 클라이언트 사용자 컴퓨터로 다운로드 되어 사용자 컴퓨터에 설치된 웹 브라우저에 의해 실행

\-   사용자에게 GUI 환경을 제공하는 간단한 기능 구현

\-   애플릿을 실행하기 위해서는 자바 가상 기계가 있어야 함

 

##### 자바 서블릿(servlet) 응용프로그램

\-   서버에서 실행되는 서버용 자바 프로그램으로 웹 서버에 의해 실행 제어

\-   웹 브라우저 상에서 실행되는 애플릿이나 자바 스크립트 코드와 통신

\-   데이터베이스나 다른 서버와 연동하여 대규모 복잡한 응용프로그램 구현에 사용

 

##### 모바일 응용프로그램

\-   자바는 플랫폼 독립적, 적은 메모리 사용, 통신 환경 지원하도록 설계되어 있기 때문에

\-   다양한 하드웨어, 소프트웨어 플랫폼을 갖는 모바일 기기에 적합

\-   다양한 모바일 응용프로그램 개발에 사용

\-   안드로이드

**■   구글의 주도하에 여러 모바일 회사가 모여 구성한 OHA(Open Handset Alliance)에서 개발한 무료 모바일 플랫폼**

\-   Java ME (모바일 기기용 배포 판)

**■   게임, 임베디드 및 가전제품, 멀티미디어 응용프로그램 작성에 사용**

 

### 자바 개발 환경 설정

자바 개발 환경

1. JDK (Java Development Kit)

\-   자바 응용프로그램을 개발하고 실행하는데 필요한 총체적 환경

\-   다운로드 및 설치 / 환경 변수 설정

2. 이클립스 (Eclipse)

\-   자바 통합 개발 환경 (IDE : Integrated Development Environment)

\-   오픈 소스 소프트웨어로 무료 다운로드 사용

\-   다운로드 / 설치 사용

JDK (Java Development Kit) 구성 내용

**■   컴파일러**

**◆  자바 응용프로그램을 개발하는데 필요한 도구**

**◆  컴파일 : 고급언어를 컴퓨터가 이해할 수 있는 기계어로 변환**

**◆  컴파일러 : 컴파일을 수행하는 프로그램**

**■   자바 가상 기계 (Java Virtual Machine – JVM)**

**◆  자바 응용프로그램이 실행될 때 필요**

\-   JRE (Java Run-time Environment)

**■   표준 클래스 파일 포함**

 

##### 자바 중요 개발 도구들

\-   JDK의 bin 디렉터리에 exe 파일로 포함

\-   javac :자바 소스를 바이트 코드로 변환하는 컴파일러

\-   java : 자바 응용프로그램 실행

\-   javadoc : HTML 형태의 API 도큐먼트 생성

\-   jar : 자바 클래스 파일을 압축한 JAR 파일 생성 관리

\-   jdb : 실행 중 오류를 찾는데 사용하는 디버거

 

##### 자바 패키지 (package)

\-   자바에서 서로 관련된 클래스들을 분류하여 묶어 놓은 것

\-   import하여 사용

##### 자바 API

\-   주요 기능들을 미리 구현한 클래스 라이브러리로 묶어 놓은 패키지들

\-   API를 이용하여 쉽고 빠르게 자바 프로그램 개발

##### API 도큐먼트

\-   JDK에서 제공하는 표준 클래스 라이브러리 설명해 놓은 HTML 페이지들

 

#### JDK 배포 판

\-   Java SE (Standard Edition) 

■   자바 표준 배포 판 

\-   Java ME (Micro Edition) 

■   모바일용 배포 판

■   Java SE 축소판으로 임베디드 및 가전제품을 위한 API 정의 포함

Java EE (Enterprise Edition) 

\-   기업용 배포 판

\-   Java SE 를 기본으로 인터넷 기반의 서버사이드 컴퓨팅 관련 API 추가

 

#### 이클립스 (Eclipse)

\-   2003년 IBM에서 개발

\-   자바 통합 개발 환경(IDE) 제공

■   프로젝트 생성 / 자동 코드 완성 / 디버깅 기능 제공

\-   이클립스 연합(Eclipse Foundation) 설립

■   지속적 버전업과 배포

\-   다양한 개발 환경을 구축할 수 있도록 플러그인(Plug-In) 설치 가능

■   안드로이드 개발 환경

■   스프링(Spring) 개발 환경 (STS)

■   C, C++ 개발 환경

   

### 자바 프로그램 작성 및 프로그램 기본 구조



>  #### 자바 프로그램 작성 순서



(1)     프로젝트 생성

**자바 소스 파일, 리소스(이미지, 동영상 등), 클래스 파일 등 관리**

\-   메뉴 : File / New / Java Project

\-   Project name : TestProject  (대문자 시작)

\-   Module : Create module-info java file 체크 해제

\-   Finish

 

(2)     (패키지 추가 후) 자바 클래스 추가

\-   패키지 생성하지 않을 시 클래스 생성 : default package 사용

\-   메뉴 : New / Class

\-   Name : Test (대문자로 시작)

\-   main() 메소드 포함 

■   public static void main(String[] args) 체크

■   Finish

 

(3)     코드 입력

System.out.println(“test 입니다”);

 

(4)     실행 / 결과 확인

\-   메뉴 : Run / Run 

\-   콘솔창에 출력 : test 입니다

 

> ##### 자바 클래스 생성

\-   클래스명으로 java 파일이 생성됨

\-   클래스명 : Test

\-   생성되는 파일명 : Test.java

\-   대소문자 구분

 

>  #### 소스 작성에서 실행까지 과정

자바 프로그램의 기본 구조

클래스 이름 : Hello

- main() 메소드

​	\-   자바 응용프로그램 실행은 main()부터 시작

​	\- 프로그램을 실행할 때 ‘java.exe’에 의해 호출될 수 있도록 미리 약속된 부분

​	\- public static void main(String[] args)

​	\- 항상 동일하게 작성

- public

​	\- 다른 클래스에서 main() 메소드에 접근 허용 (실행 시 자바 가상 기계가 호출할 수 있도록 접근 허용)

- static

​	\- 객체 생성(인스턴스) 생성하지 않고도 호출 가능

​	\- main() 메소드가 포함된 클래스의 객체(인스턴스)가 생성되기 전에 자바 가상 기계가 호출해야 하므로 static으로 선언)

- void

​	\- 반환(return)값 없음을 의미

​	\- 작업 수행하고 메소드 종료

- (String[] args)

​	n main() 호출하면서 전달되는 값을 받는 매개변수로 문자열 배열

​	\-   하나의 클래스에 main() 메소드는 하나만 존재

​	\-   클래스마다 main() 메소드 존재할 수 있지만

​	\-   .java 파일명과 동일한 public 클래스의 main()에서부터 실행 시작

 

하나의 java 파일에 여러 개의 클래스 존재 가능

public 클래스는 하나만 존재 – 이 public 클래스 이름이 파일명이 됨

 

 

#### 주석문

\-   프로그램에 대한 설명문 (컴파일러가 무시)

\-   프로그램 실행에 영향 없음

\-   코드가 1줄인 경우 주석 : //

\-   여러 행인 경우 주석 : /*  ……. */

\-   블록 주석 설정 : Ctrl + Shift + /

\-   블록 주석 해제 : Ctrl + Shift + \

 

> ##### 블록 주석 시 자동 정렬되는 문제

\-   블록 주석 시 포맷팅 적용하지 않도록 설정

\-   Window / Preferences

\-   Java / Code Style / Formatter

\-   New : NewProfile 생성 [OK]

\-   Comments / Enable block comment formatting 체크 해제

 

#### 주석을 사용하는 이유

\-   프로그램에 관한 정보를 추가할 수 있다

\-   수정이 용이하다

\-   가독성을 높여 준다

\-   코드를 이해하기 쉽다

\-   다른 사람이 작성한 코드를 쉽게 해석할 수 있다

##### 문장

\-   문장의 끝을 표시하기 위해 세미콜론(;) 사용

\-   한 문장을 여러 줄로 작성할 수 있지만-  ;을 만날 때 문장 끝으로 인식

##### 블록 { }

\-   클래스, 메소드, 반복문, 조건문에서 영역 범위 표시

\-   public class Hello {

}

\-   public static void main(String[] args) {

}

 

*에러와 해결 방법*

\-   콘솔(Console) 창에 에러 메시지 출력

\-   읽어 보고 라인 클릭해서 오류 처리



# 변수 (variable)

\-   프로그램 실행 중에 1개의 값을 저장하기 위한 

\-   메모리 내의 임시 기억장소 (메모리 공간)

![clip_image012](https://user-images.githubusercontent.com/101630615/173629221-9c012cb6-b46a-4df9-9054-b72d30075c2a.jpg)

### 변수의 특징

\-   이름이 있다 - 변수명 (메모리 주소에 붙여진 이름)

\-   기억장소 내에서의 주소가 있다

\-   변수에 저장되는 값이 있다

\-   저장되는 값의 유형(데이터 타입)이 있고 크기가 다르다

\-   프로그램 실행 중에 저장된 값이 변경될 수 있다

\-   주의! - 변수는 동일한 이름으로 한 번만 선언

\-   두 번 선언하면 오류 (중복 선언 오류)



#### 정수 타입 변수와 문자 타입 변수 예



![clip_image014](https://user-images.githubusercontent.com/101630615/173629223-6c57471f-767e-4ab7-a728-7e3630b75dbd.jpg)



변수는

\-   저장되는 값에 따라 유형(데이터 타입)이 있고

\-   데이터 타입에 따라 크기가 다르다

### 변수 이름을 위한 명명규칙 



![clip_image016](https://user-images.githubusercontent.com/101630615/173629227-8a285056-9288-45f9-979c-19e815a7e675.jpg)

**주의!!!**

\-   변수 이름 사이에 공백을 포함할 수 없다 (띄어쓰기 하면 안된다)

 

#### 자바 예약어

\-   자바 키워드

\-   자바 시스템에서 지정하여 사용하는 단어 (이미 맡아놓은 단어)

\-   클래스명, 메소드명, 각종 변수명으로 사용할 수 없음

\-   모두 소문자로 되어 있음

 

![clip_image018](https://user-images.githubusercontent.com/101630615/173629230-eebabf63-7211-4219-a890-6d7846507c41.jpg)

 

 

### 변수의 선언

\-   변수를 사용하기 위해서는 반드시 변수를 선언해야 한다.

\-   선언하지 않으면 오류 발생

\-   ``변수명 cannot be resolved to a variable (변수를 선언하지 않고 사용하는 경우의 오류 메시지)``

\-   변수를 선언하는 이유

\-   실행 중에 필요한 공간 할당 받기 위해

#### 선언 형식

```
데이터 타입 변수명;

int a;
:  정수 타입 변수 a 선언, 4바이트

char c;
: 문자 타입 변수 c 선언, 2바이트

float f;
: 실수 타입 변수 f 선언, 4바이트   

선언된 변수에 값 저장
변수명 = 값;
저장소 = 값;   
```



####  대입 연산자 =의 오른쪽의 값을 왼쪽의 저장소에 저장

![clip_image020](https://user-images.githubusercontent.com/101630615/173629233-3bc43a65-c59f-4c78-8478-2834cfaca42e.jpg)

 

### 변수 초기화

\-   변수 선언과 동시에 값 저장

![clip_image022](https://user-images.githubusercontent.com/101630615/173629234-f6943860-9db2-4125-8f36-bdc4e25140ac.jpg)

***주의!!***

\-   초기화 되지 않은 변수 사용 시 오류 발생

```
int value;  // 선언만하고 초기화 안 했음

int result = value + 10; // 변수 value에 10을 더한 결과를 변수 result에 저장

The local variable value may not have been initialized // value가 초기화 되지 않았다고 오류 발생

int value = 30; // 초기화 한 후 

int result = value + 10; // 변수 사용
```

 

### 상수 (Constant)

\-   프로그램 실행 중에 값을 저장하기 위한 메모리 내의 임시 기억장소

\-   정해진 값을 가지며, 프로그램 실행 중 값이 변하지 않음

\-   ``final`` 키워드 사용

\-   대문자로 선언

  ##### 상수의 용도 

\-   프로그램 실행 중에 값이 변해서는 안 되는 것을 상수로 선언

\-   실수하지 않도록 상수로 선언하고 상수명으로 사용하면 잘못 입력 시 컴파일러가 오류로 알려줌

```
int price = 100; //변수

price = 200; // 변수는 값 변경 가능

final int PRICE = 1000; // final로 선언한 상수

PRICE = 2000; // 오류 - 상수값은 변경 불가능

PRIC * qty : 상수 스펠링 잘못 입력하면 컴파일러가 오류를 알려줌
```



#### 리터럴 (Literal)

\-   변수에 저장되는 값

`````
int x = 30; // 30; 리터럴

double pi = 3.14; // 3.14; 리터럴
`````



### 리터럴 종류

> #### 정수 리터럴

\-   0, 75, -100 : 소수점이 없는 정수 리터럴은 10진수

\-   015 : 0으로 시작하는 정수 리터럴은 8진수

\-   0x15 : 0x 또는 0X로 시작하는 리터럴은 16진수

\-   0xAC08



>  #### 실수 리터럴

\-   0.25, -3.14 : 소수점이 있는 실수 리터럴 10진수

\-   대문자 E가 있는 리터럴은 10진수 지수와 가수

\-   5E7 // 5 x 107

\-   0.12E-5 // 0.12 x 10-5

 

>  #### 문자 리터럴

\-   작은 따옴표(‘’)로 묶은 텍스트는 하나의 문자 리터럴

\-   ‘A’, ‘한’, ‘\t’, ‘\n’

***특수 문자 (escape 문자)***

\-   역 슬래시(\)가 붙은 리터럴

\-   ``‘\t’`` : 수평 탭을 나타내는 특수문자

\-  `` ‘\n’`` : 줄 바꿈을 나타내는 특수문자(개행문자)



> #### 문자열 리터럴

\-   큰 따옴표(“”)로 묶은 텍스트는 문자열 리터럴

\-   “대한민국”, “name”, “홍길동”, “010-1234-5678”

\-   “탭 만큼 이동 ``\t``합니다” - 문자열 안에 특수문자 포함 가능

\-   “한 줄 내려 쓰기 ``\n`` 합니다”



>  #### 논리 리터럴

\-   true, false 값



#### 변수의 사용 범위

\-   변수는 선언된 블록({ }) 내에서만 사용 가능

\-   변수의 사용 범위, 위치를 결정해서 선언

![clip_image024](https://user-images.githubusercontent.com/101630615/173629239-b51cce8c-5d30-433d-b0c6-30e895da935b.jpg)

![clip_image026](https://user-images.githubusercontent.com/101630615/173629242-7d4833b2-a723-48ee-9e53-39c4c6099ab4.jpg)

 

# Java의 데이터 타입

> #### 기본 타입 (기본형)

​	\-   문자 타입 (1개) : char (교재에서는 정수 타입으로 분류)

​	\-   정수 타입 (4개) : byte / short / int / long

​	\-   실수 타입 (2개) : float / double

​	\-   논리 타입 (1개) : boolean

\-   정수, 실수, 문자, 논리 리터럴을 직접 저장하는 타입

\-   실제 값을 저장

\-   참조형

\-   기본 타입을 제외한 나머지 (String, 배열 등)

\-   참조값(객체의 주소값) 저장

#### 변수와 데이터 타입과의 관계

\-   변수는 선언된 타입과 동일한 데이터 타입의 데이터만 저장 가능

\-   즉, 정수 타입으로 선언된 변수에는 정수 타입의 값만 저장 가능

```
int score = 95; 

double average = 88.5; 

char familyName = '김'; 

String name = "홍길동"; 

 boolean result = true; 
```

**데이터 타입과 메모리 사용 크기**

\-   데이터 타입에 따라 사용하는 메모리 크기가 다름

**메모리 크기**

\-   메모리의 최소 단위 : bit (비트)

\-   1 bit에는 0 또는 1 (1개) 저장 가능

\-   8개의 bit가 모여서 1 byte 형성

\-   8 bit = 1 byte

![clip_image028](https://user-images.githubusercontent.com/101630615/173629245-6d053b5e-de90-498f-893b-a52feb129600.jpg)

**기본 타입의 크기**

\-   각 데이터 타입의 크기는 정해져 있음

![clip_image030](https://user-images.githubusercontent.com/101630615/173629247-6ee5f451-b725-4aa1-96fc-fcd8e2b921ec.jpg)

**데이터 타입의 크기의 의미**

\-   크기에 따라 변수에 저장할 수 있는 값의 범위가 다름

![clip_image032](https://user-images.githubusercontent.com/101630615/173629251-6365f60f-512b-4479-ba0a-9f7dd8d41a6b.jpg)



**기본 타입의 메모리 크기와 저장되는 값의 범위**

![clip_image034](https://user-images.githubusercontent.com/101630615/173629252-5dc0a05e-af69-4242-bab4-1ded4f7ca451.jpg)

>  #### 자바에서의 문자 표현

\-   자바는 모든 문자를 유니코드로 처리

\-   유니코드 (Unicode)

\-   세계의 모든 문자 표현 가능

\-   하나의 문자에 하나의 코드값 부여

\-   0 ~ 65535 범위 2 byte 크기의 정수값

\-   ‘A’ ; ‘\u0041’

 

**char 타입**

\-   2 byte

\-   문자 타입 또는 정수 타입으로 분류

\-   문자 값 또는 문자에 해당되는 정수 값 저장 가능

\-   주의! : 빈 값(공백) 초기화 할 경우 ‘’하면 오류

\-   스페이스를 포함시켜야 함 : ``‘ ‘``

\-  `` ''``: 스페이스 없으면 오류



> #### 정수 타입

**int 타입**

\-   4 byte 정수 값을 저장하기 위한 타입

\-   정수 연산을 하기 위한 기본 타입

\-   일반적으로 정수를 저장할 때 int 타입 사용

**long 타입**

\-   8 byte 정수 값을 저장하기 위한 타입

\-   정수 값 뒤에 소문자 ``l`` 또는 대문자 ``L``을 붙여서 사용

\-   4 byte 정수가 아니라 8 byte 정수라는 것을 알려 주기 위함

\-   int 타입의 범위를 넘어서는 큰 정수는 반드시 ``l`` 또는 ``L``을 붙여야 함 (안 붙이면 오류)



>  #### 실수 타입

\-   소수점이 있는 실수값을 저장하기 위한 타입

\-   float : 4 byte

\-   double : 8 byte

\-   float에 비해 double이 약 두 배의 자릿수가 배정되어 있기 때문에 더 정밀한 값 저장 가능

\-   정밀도를 요구하는 계산에서는 double 사용

```
float average = 88.5f;
: float 타입의 리터럴에서 소문자 ``f`` 또는 대문자 ``F`` 붙임

double average = 88.5;
: double 타입이 기본이기 때문에 리터럴에 아무것도 붙이지 않음
```

\-   정수 타입과 같은 크기이지만 저장 방식이 다르기 때문에 

\-   정수 타입보다 훨씬 큰 범위의 값 저장 가능

\-   부동 소수점 방식으로 저장

\-   부호비트 + 지수부 + 가수부

![clip_image036](https://user-images.githubusercontent.com/101630615/173629253-269bf320-d01e-43b9-ab46-69c84256eec4.jpg)

 

> #### 논리 타입 (boolean)

\-   1 byte로 표현되는 논리값(true/false)을 저장할 수 있는 데이터 타입

\-   상태 값에 따라 조건문과 반복문의 실행 흐름을 변경하는데 사용

 

# 타입 변환 (형변환)

\-   데이터 타입을 다른 타입으로 변환하는 것

```
 byte ←→ int, int ←→ double
```

**타입 변환 종류**

\-   자동(묵시적) 타입 변환 : ``Promotion``

\-   강제(명시적) 타입 변환 : ``Casting``

**자동 타입 변환**

\-   프로그램 실행 도중 자동적으로 타입 변환이 일어나는 것

\-   작은 크기의 타입이 큰 크기의 타입에 저장될 때 발생

\-   작은 타입이 큰 타입으로 자동 타입 변환

![clip_image040](https://user-images.githubusercontent.com/101630615/173629255-a4e35eca-1dc5-4913-85c0-e79266c61ebd.jpg)

#### 데이터 타입의 크기 순

\-   바이트 크기가 아닌, 값의 표현 범위에 따라 크기 규정

![clip_image042](https://user-images.githubusercontent.com/101630615/173629256-9eda4a4d-cd7b-4a84-b19b-674efc3be750.jpg)

 

 

#### 타입 불일치오류

\-   크기가 큰 타입의 값을 크기가 작은 타입의 변수에 저장할 경우 데이터의 손실 발생 - 오류 발생

![clip_image044](https://user-images.githubusercontent.com/101630615/173629257-1fc60670-342c-443d-a76a-9eaeeef49e24.jpg)

 

#### 강제 타입 변환

\-   큰 크기의 타입을 작은 크기의 타입으로 강제로 변환하는 것

\-   큰 타입을 작은 타입 단위로 쪼개서

\-   끝의 해당되는 부분만 작은 타입으로 강제적으로 변환됨

![clip_image046](https://user-images.githubusercontent.com/101630615/173629258-f0bb922c-030e-446e-bd03-324790b2153c.jpg)

***\-   주의 ! : 데이터의 일부 손실 발생***

![clip_image048](https://user-images.githubusercontent.com/101630615/173629266-d285c2e6-8fee-4860-b0e1-d94dda9dfcf6.jpg)

 

#### 강제 타입 변환 시 주의

\-   값의 손실 발생

\-   타입 변환 시 값의 손실을 막기 위해 타입의 범위 확인

\-   변환할 타입의 최대값 / 최소값을 벗어나는지 검사하고 타입 변환 시도

\-   Byte.MIN_VALUE / Byte.MAX_VALUE

\-   정밀도 손실 발생

\-   float의 가수 보다 큰 int 값을 float으로 변환할 때 손실 발생

\-   int 값을 실수로 변환하려면 double 타입 사용

**\-   문자열(String)은 char 타입으로 강제 타입 변환 불가능**

![clip_image050](https://user-images.githubusercontent.com/101630615/173629267-dc7f0377-4195-47df-ab60-5542a4f51c68.jpg)

 

#### 연산식에서 자동 타입 변환

\-   연산은 같은 타입의 피연산자(operand)간에만 수행

\-   int 타입 변수 + int 타입 변수

\-   서로 다른 타입의 피연산자 경우

\-   두 피연산자 중 크기가 큰 타입으로 자동 변환

![clip_image052](https://user-images.githubusercontent.com/101630615/173629270-d2776a98-bd06-4ebc-af49-10ce58a327ba.jpg)

\-   정수 연산인 경우 : int 타입이 기본 (4 byte)

\-   4 byte 보다 작은 타입(byte, char, short)은 int 타입으로 변환된 후 연산 수행





#### Scanner 클래스를 이용한 키 입력

\-   Scanner 객체가 키보드로부터 입력한 값을 바이트로 읽어 들여 데이터 형에 맞춰 변환하여 반환

![clip_image054](https://user-images.githubusercontent.com/101630615/173629273-92fd6c0a-d5a2-4fe7-9c2e-57fbd72ef5c6.jpg)

입력한 값을 데이터 타입에 맞춰 변환하는 메소드

```
next() : 문자열 타입으로 반환

nextInt() : int 타입으로 반환

nextByte() / nextShort() / nextLong() / nextFloat() / nextDouble()

nextLine() : ‘\n’까지 포함한 라인 전체를 문자열로 반환
```

Scanner 클래스를 사용하기 위해서는 패키지 포함

\-   import java.util.Scanner;

\-   자동 import : Ctrl + Shift + O

\-   생성한 객체는 사용 후 리소스 낭비를 막기 위해 close() 함

\-   sc.close()